import yahooFinance from 'yahoo-finance2';
import { StockCall, MarketDataPoint, StockWithMarketData, MarketIndices, dummyStockCalls } from '@/data/stock-calls';

// Cache for market data to avoid repeated API calls
const marketDataCache = new Map<string, MarketDataPoint[]>();
const CACHE_EXPIRY = 5 * 60 * 1000; // 5 minutes
const cacheTimestamps = new Map<string, number>();

export async function fetchHistoricalData(
  ticker: string,
  period: { start: Date; end: Date }
): Promise<MarketDataPoint[]> {
  const cacheKey = `${ticker}-${period.start.getTime()}-${period.end.getTime()}`;
  const now = Date.now();

  // Check cache first
  if (marketDataCache.has(cacheKey) && cacheTimestamps.has(cacheKey)) {
    const timestamp = cacheTimestamps.get(cacheKey)!;
    if (now - timestamp < CACHE_EXPIRY) {
      return marketDataCache.get(cacheKey)!;
    }
  }

  try {
    const result = await yahooFinance.historical(ticker, {
      period1: period.start,
      period2: period.end,
      interval: '1d',
      includePrePost: false
    });

    const marketData: MarketDataPoint[] = (Array.isArray(result) ? result : []).map((day: any) => ({
      date: day.date.toISOString().split('T')[0],
      open: day.open,
      high: day.high,
      low: day.low,
      close: day.close,
      volume: day.volume,
      adjClose: day.adjClose || day.close
    }));

    // Cache the result
    marketDataCache.set(cacheKey, marketData);
    cacheTimestamps.set(cacheKey, now);

    return marketData;
  } catch (error) {
    console.error(`Error fetching data for ${ticker}:`, error);
    throw new Error(`Failed to fetch historical data for ${ticker}`);
  }
}

export async function fetchMarketIndices(
  period: { start: Date; end: Date }
): Promise<MarketIndices> {
  try {
    const [jkseData, lq45Data] = await Promise.all([
      fetchHistoricalData('^JKSE', period),
      fetchHistoricalData('^LQ45', period)
    ]);

    return {
      jkse: jkseData,
      lq45: lq45Data
    };
  } catch (error) {
    console.error('Error fetching market indices:', error);
    throw new Error('Failed to fetch market indices data');
  }
}

function calculateGains(
  historicalData: MarketDataPoint[],
  entryPrice: number,
  callDate: string
): { maxGain: number; currentGain: number; daysToMax: number | null } {
  if (historicalData.length === 0) {
    return { maxGain: 0, currentGain: 0, daysToMax: null };
  }

  // Find the index of the call date
  const callDateIndex = historicalData.findIndex(
    day => day.date >= callDate
  );

  if (callDateIndex === -1) {
    // If call date is not in historical data, use the first day
    const firstClose = historicalData[0].close;
    const currentClose = historicalData[historicalData.length - 1].close;
    return {
      maxGain: 0,
      currentGain: ((currentClose - entryPrice) / entryPrice) * 100,
      daysToMax: null
    };
  }

  // Calculate gains from call date onwards
  const dataFromCall = historicalData.slice(callDateIndex);

  if (dataFromCall.length === 0) {
    return { maxGain: 0, currentGain: 0, daysToMax: null };
  }

  let maxGain = 0;
  let daysToMax: number | null = null;
  let maxGainDate: string | null = null;

  // Find maximum gain
  for (let i = 0; i < dataFromCall.length; i++) {
    const day = dataFromCall[i];
    const gain = ((day.close - entryPrice) / entryPrice) * 100;

    if (gain > maxGain) {
      maxGain = gain;
      daysToMax = i;
      maxGainDate = day.date;
    }
  }

  // Calculate current gain
  const currentClose = dataFromCall[dataFromCall.length - 1].close;
  const currentGain = ((currentClose - entryPrice) / entryPrice) * 100;

  return {
    maxGain,
    currentGain,
    daysToMax
  };
}

function calculateIndexReturn(
  indexData: MarketDataPoint[],
  startDate: string,
  endDate: string
): number | undefined {
  const startIndex = indexData.findIndex(day => day.date >= startDate);
  const endIndex = indexData.findIndex(day => day.date >= endDate);

  if (startIndex === -1 || endIndex === -1 || startIndex >= endIndex) {
    return undefined;
  }

  const startPrice = indexData[startIndex].close;
  const endPrice = indexData[endIndex].close;

  return ((endPrice - startPrice) / startPrice) * 100;
}

export async function fetchStocksWithMarketData(
  stockCalls: StockCall[] = dummyStockCalls,
  lookbackDays: number = 365
): Promise<{ stocks: StockWithMarketData[]; marketIndices: MarketIndices }> {
  const endDate = new Date();
  const startDate = new Date(endDate.getTime() - (lookbackDays * 24 * 60 * 60 * 1000));

  try {
    // Fetch market indices data
    const marketIndices = await fetchMarketIndices({ start: startDate, end: endDate });

    // Fetch individual stock data
    const stockDataPromises = stockCalls.map(async (stock) => {
      try {
        const historicalData = await fetchHistoricalData(stock.ticker, {
          start: startDate,
          end: endDate
        });

        const { maxGain, currentGain, daysToMax } = calculateGains(
          historicalData,
          stock.entryPrice,
          stock.callDate
        );

        // Calculate index returns for comparison
        const jkseReturn = calculateIndexReturn(
          marketIndices.jkse,
          stock.callDate,
          endDate.toISOString().split('T')[0]
        );

        const lq45Return = calculateIndexReturn(
          marketIndices.lq45,
          stock.callDate,
          endDate.toISOString().split('T')[0]
        );

        return {
          ...stock,
          historicalData,
          maxGain,
          currentGain,
          daysToMax,
          jkseReturn,
          lq45Return
        } as StockWithMarketData;
      } catch (error) {
        console.error(`Error processing ${stock.ticker}:`, error);
        // Return stock with default values if fetch fails
        return {
          ...stock,
          historicalData: [],
          maxGain: 0,
          currentGain: ((stock.currentPrice - stock.entryPrice) / stock.entryPrice) * 100,
          daysToMax: null
        } as StockWithMarketData;
      }
    });

    const results = await Promise.all(stockDataPromises);

    // Sort by current gain (highest first)
    const sortedResults = results.sort((a, b) => b.currentGain - a.currentGain);

    return {
      stocks: sortedResults,
      marketIndices
    };

  } catch (error) {
    console.error('Error fetching stocks with market data:', error);
    throw new Error('Failed to fetch stocks with market data');
  }
}

// Helper function to format currency
export function formatCurrency(amount: number, currency: string = 'IDR'): string {
  return new Intl.NumberFormat('id-ID', {
    style: 'currency',
    currency,
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(amount);
}

// Helper function to format percentage
export function formatPercentage(value: number, decimals: number = 2): string {
  return `${value.toFixed(decimals)}%`;
}

// Helper function to calculate relative performance
export function calculateRelativePerformance(
  stockGain: number,
  indexGain?: number
): { outperformance: number; isOutperforming: boolean } {
  if (indexGain === undefined) {
    return { outperformance: 0, isOutperforming: false };
  }

  const outperformance = stockGain - indexGain;
  return {
    outperformance,
    isOutperforming: outperformance > 0
  };
}

// Re-export dummyStockCalls for convenience
export { dummyStockCalls };

export async function refreshMarketData(tickers: string[]): Promise<void> {
  const endDate = new Date();
  const startDate = new Date(endDate.getTime() - (365 * 24 * 60 * 60 * 1000));

  const refreshPromises = tickers.map(async (ticker) => {
    const cacheKey = `${ticker}-${startDate.getTime()}-${endDate.getTime()}`;
    try {
      const result = await yahooFinance.historical(ticker, {
        period1: startDate,
        period2: endDate,
        interval: '1d'
      });

      const marketData: MarketDataPoint[] = (Array.isArray(result) ? result : []).map((day: any) => ({
        date: day.date.toISOString().split('T')[0],
        open: day.open,
        high: day.high,
        low: day.low,
        close: day.close,
        volume: day.volume,
        adjClose: day.adjClose || day.close
      }));

      marketDataCache.set(cacheKey, marketData);
      cacheTimestamps.set(cacheKey, Date.now());
    } catch (error) {
      console.error(`Error refreshing data for ${ticker}:`, error);
    }
  });

  await Promise.all(refreshPromises);
}